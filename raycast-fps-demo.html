<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raycast FPS Demo</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: monospace;
        }
        #game-canvas {
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            cursor: crosshair;
            border: 2px solid #333;
        }
        #debug-info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #0f0;
            font-size: 14px;
            pointer-events: none;
            z-index: 100;
        }
        #instructions {
            position: fixed;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 12px;
            text-align: center;
        }
        #click-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 20px;
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 10px;
            pointer-events: none;
            z-index: 200;
        }
        #click-hint.hidden { display: none; }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    <div id="debug-info"></div>
    <div id="instructions">WASD: hareket | Mouse: dÃ¶nme | ESC: mouse'u serbest bÄ±rak</div>
    <div id="click-hint">ðŸŽ® BaÅŸlamak iÃ§in tÄ±kla</div>

    <script>
    // ============================================
    // CONFIG
    // ============================================
    const SCREEN = { WIDTH: 640, HEIGHT: 400, SCALE: 2 };
    const PLAYER_CONFIG = {
        MOVE_SPEED: 3.0,
        ROTATION_SPEED: 2.0,
        MOUSE_SENSITIVITY: 0.002,
        RADIUS: 0.25,
        START_X: 2.5,
        START_Y: 2.5,
        START_ANGLE: 0
    };
    const RAYCASTER = { FOV: Math.PI / 3, MAX_DEPTH: 20, WALL_HEIGHT: 1.0 };
    const COLORS = {
        CEILING: '#1a1a2e',
        FLOOR: '#16213e',
        WALL_NORTH: '#e94560',
        WALL_SOUTH: '#c73e54',
        WALL_EAST: '#0f3460',
        WALL_WEST: '#0a2647'
    };

    // ============================================
    // GAME STATE
    // ============================================
    const game = {
        lastTime: 0,
        deltaTime: 0,
        fps: 0,
        frameCount: 0,
        fpsUpdateTime: 0,
        isRunning: false,
        debug: { showMinimap: true, showRays: false, noclip: false }
    };

    // ============================================
    // INPUT
    // ============================================
    const keys = { forward: false, backward: false, left: false, right: false };
    let mouseDeltaX = 0;
    let isPointerLocked = false;

    function initInput(canvas) {
        window.addEventListener('keydown', e => updateKey(e.code, true));
        window.addEventListener('keyup', e => updateKey(e.code, false));
        
        canvas.addEventListener('click', () => {
            if (!isPointerLocked) canvas.requestPointerLock();
        });
        
        document.addEventListener('pointerlockchange', () => {
            isPointerLocked = document.pointerLockElement === canvas;
            document.getElementById('click-hint').classList.toggle('hidden', isPointerLocked);
        });
        
        document.addEventListener('mousemove', e => {
            if (isPointerLocked) {
                mouseDeltaX += e.movementX * PLAYER_CONFIG.MOUSE_SENSITIVITY;
            }
        });
    }

    function updateKey(code, pressed) {
        switch (code) {
            case 'KeyW': case 'ArrowUp': keys.forward = pressed; break;
            case 'KeyS': case 'ArrowDown': keys.backward = pressed; break;
            case 'KeyA': keys.left = pressed; break;
            case 'KeyD': keys.right = pressed; break;
        }
    }

    function consumeMouseDelta() {
        const delta = mouseDeltaX;
        mouseDeltaX = 0;
        return delta;
    }

    // ============================================
    // MAP
    // ============================================
    const mapData = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,1,1,1,0,0,0,0,1,1,1,0,0,1],
        [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
        [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
        [1,0,0,1,0,0,0,0,0,0,0,0,1,0,0,1],
        [1,0,0,1,1,1,0,0,0,0,1,1,1,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    const map = {
        data: mapData,
        width: mapData[0].length,
        height: mapData.length,
        isWall(x, y) {
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) return true;
            return this.data[y][x] === 1;
        }
    };

    // ============================================
    // PLAYER
    // ============================================
    const player = {
        x: PLAYER_CONFIG.START_X,
        y: PLAYER_CONFIG.START_Y,
        angle: PLAYER_CONFIG.START_ANGLE,
        radius: PLAYER_CONFIG.RADIUS
    };

    function updatePlayer() {
        const dt = game.deltaTime;
        
        // Rotation
        player.angle += consumeMouseDelta();
        player.angle = player.angle % (Math.PI * 2);
        if (player.angle < 0) player.angle += Math.PI * 2;
        
        // Movement
        let moveX = 0, moveY = 0;
        const cos = Math.cos(player.angle);
        const sin = Math.sin(player.angle);
        const speed = PLAYER_CONFIG.MOVE_SPEED * dt;
        
        if (keys.forward) { moveX += cos * speed; moveY += sin * speed; }
        if (keys.backward) { moveX -= cos * speed; moveY -= sin * speed; }
        if (keys.left) { moveX += sin * speed; moveY -= cos * speed; }
        if (keys.right) { moveX -= sin * speed; moveY += cos * speed; }
        
        // Collision (sliding)
        if (!game.debug.noclip) {
            const newX = player.x + moveX;
            const newY = player.y + moveY;
            if (!isColliding(newX, player.y)) player.x = newX;
            if (!isColliding(player.x, newY)) player.y = newY;
        } else {
            player.x += moveX;
            player.y += moveY;
        }
    }

    function isColliding(x, y) {
        const r = player.radius;
        const points = [[x-r, y-r], [x+r, y-r], [x-r, y+r], [x+r, y+r]];
        return points.some(([px, py]) => map.isWall(Math.floor(px), Math.floor(py)));
    }

    // ============================================
    // RAYCASTING
    // ============================================
    function castRays() {
        const rays = [];
        const numRays = SCREEN.WIDTH;
        
        for (let i = 0; i < numRays; i++) {
            const rayAngle = player.angle - RAYCASTER.FOV/2 + (i/numRays) * RAYCASTER.FOV;
            const ray = castSingleRay(rayAngle);
            ray.correctedDistance = ray.distance * Math.cos(rayAngle - player.angle);
            rays.push(ray);
        }
        return rays;
    }

    function castSingleRay(angle) {
        const dirX = Math.cos(angle);
        const dirY = Math.sin(angle);
        
        let mapX = Math.floor(player.x);
        let mapY = Math.floor(player.y);
        
        const deltaDistX = Math.abs(1 / dirX);
        const deltaDistY = Math.abs(1 / dirY);
        
        let stepX, stepY, sideDistX, sideDistY;
        
        if (dirX < 0) {
            stepX = -1;
            sideDistX = (player.x - mapX) * deltaDistX;
        } else {
            stepX = 1;
            sideDistX = (mapX + 1 - player.x) * deltaDistX;
        }
        
        if (dirY < 0) {
            stepY = -1;
            sideDistY = (player.y - mapY) * deltaDistY;
        } else {
            stepY = 1;
            sideDistY = (mapY + 1 - player.y) * deltaDistY;
        }
        
        let hit = false, side = 0, distance = 0;
        
        while (!hit && distance < RAYCASTER.MAX_DEPTH) {
            if (sideDistX < sideDistY) {
                sideDistX += deltaDistX;
                mapX += stepX;
                side = 0;
            } else {
                sideDistY += deltaDistY;
                mapY += stepY;
                side = 1;
            }
            if (map.isWall(mapX, mapY)) hit = true;
        }
        
        if (side === 0) {
            distance = (mapX - player.x + (1 - stepX) / 2) / dirX;
        } else {
            distance = (mapY - player.y + (1 - stepY) / 2) / dirY;
        }
        
        let wallSide;
        if (side === 0) wallSide = stepX > 0 ? 'west' : 'east';
        else wallSide = stepY > 0 ? 'north' : 'south';
        
        return { distance, hit, side, wallSide, angle };
    }

    // ============================================
    // RENDERER
    // ============================================
    function render(ctx, rays) {
        // Sky & floor
        ctx.fillStyle = COLORS.CEILING;
        ctx.fillRect(0, 0, SCREEN.WIDTH, SCREEN.HEIGHT / 2);
        ctx.fillStyle = COLORS.FLOOR;
        ctx.fillRect(0, SCREEN.HEIGHT / 2, SCREEN.WIDTH, SCREEN.HEIGHT / 2);
        
        // Walls
        for (let i = 0; i < rays.length; i++) {
            const ray = rays[i];
            if (!ray.hit) continue;
            
            const wallHeight = (RAYCASTER.WALL_HEIGHT / ray.correctedDistance) * SCREEN.HEIGHT;
            const drawStart = Math.max(0, Math.floor((SCREEN.HEIGHT - wallHeight) / 2));
            const drawEnd = Math.min(SCREEN.HEIGHT, Math.floor((SCREEN.HEIGHT + wallHeight) / 2));
            
            let color = COLORS['WALL_' + ray.wallSide.toUpperCase()];
            const brightness = Math.max(0.2, 1 - ray.correctedDistance / RAYCASTER.MAX_DEPTH);
            
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            
            ctx.fillStyle = `rgb(${Math.floor(r*brightness)}, ${Math.floor(g*brightness)}, ${Math.floor(b*brightness)})`;
            ctx.fillRect(i, drawStart, 1, drawEnd - drawStart);
        }
    }

    function renderMinimap(ctx, rays) {
        const scale = 8, padding = 10;
        
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(padding, padding, map.width * scale, map.height * scale);
        
        ctx.fillStyle = '#fff';
        for (let y = 0; y < map.height; y++) {
            for (let x = 0; x < map.width; x++) {
                if (map.isWall(x, y)) {
                    ctx.fillRect(padding + x * scale, padding + y * scale, scale - 1, scale - 1);
                }
            }
        }
        
        // Player
        const px = padding + player.x * scale;
        const py = padding + player.y * scale;
        
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(px, py);
        ctx.lineTo(px + Math.cos(player.angle) * scale * 1.5, py + Math.sin(player.angle) * scale * 1.5);
        ctx.stroke();
        
        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.arc(px, py, 3, 0, Math.PI * 2);
        ctx.fill();
    }

    // ============================================
    // GAME LOOP
    // ============================================
    function gameLoop(currentTime) {
        if (!game.isRunning) return;
        
        // Delta time
        game.deltaTime = (currentTime - game.lastTime) / 1000;
        if (game.deltaTime > 0.1) game.deltaTime = 0.016;
        game.lastTime = currentTime;
        
        // FPS
        game.frameCount++;
        if (currentTime - game.fpsUpdateTime >= 1000) {
            game.fps = game.frameCount;
            game.frameCount = 0;
            game.fpsUpdateTime = currentTime;
        }
        
        // Update
        updatePlayer();
        
        // Render
        const rays = castRays();
        render(ctx, rays);
        
        if (game.debug.showMinimap) {
            renderMinimap(ctx, rays);
        }
        
        // Debug info
        document.getElementById('debug-info').innerHTML = 
            `FPS: ${game.fps}<br>` +
            `Pos: ${player.x.toFixed(2)}, ${player.y.toFixed(2)}<br>` +
            `Angle: ${(player.angle * 180 / Math.PI).toFixed(1)}Â°`;
        
        requestAnimationFrame(gameLoop);
    }

    // ============================================
    // INIT
    // ============================================
    const canvas = document.getElementById('game-canvas');
    canvas.width = SCREEN.WIDTH;
    canvas.height = SCREEN.HEIGHT;
    canvas.style.width = `${SCREEN.WIDTH * SCREEN.SCALE}px`;
    canvas.style.height = `${SCREEN.HEIGHT * SCREEN.SCALE}px`;
    
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = false;
    
    initInput(canvas);
    
    game.isRunning = true;
    game.lastTime = performance.now();
    
    // Debug commands
    window.game = game;
    window.noclip = () => { game.debug.noclip = !game.debug.noclip; console.log('Noclip:', game.debug.noclip); };
    window.teleport = (x, y) => { player.x = x; player.y = y; };
    
    console.log('ðŸŽ® Raycast FPS Demo');
    console.log('ðŸ“‹ Komutlar: noclip(), teleport(x, y)');
    
    requestAnimationFrame(gameLoop);
    </script>
</body>
</html>
